### 实现思路
rmq支持固定延时级别的消息，那么延时消息服务端咋实现的呢？

延时消息被服务端接收时，主题会被改写为`SCHEDULE_TOPIC_XXXX`，等到达发送时间后，恢复消息的真实主题，重新发送到真实下的消息队列中。

### 延时服务
我们先看一下延时消息服务对应的属性，就能把实现流程猜个七七八八。

+ `offsetTable`保存了延时级别 -> 偏移量，可以推测出每个延时级别对应一个队列，拥有自己的偏移量
+ `delayLevelTable`则是延时级别 -> 延时时间
+ `Timer`定时器线程
+ `defaultMessageStore`消息存储服务

看到这儿，你应该已经猜到了具体实现，无非从队列中顺序拿消息，然后判断消息是否到达发送时间，发送或继续等待。

```java
public class ScheduleMessageService{
    private static final long FIRST_DELAY_TIME = 1000L;
    private static final long DELAY_FOR_A_WHILE = 100L;
    private static final long DELAY_FOR_A_PERIOD = 10000L;

    // 延时级别（1s:1000,2s:2000 ...）
    private final ConcurrentMap<Integer /* level */, Long/* delay timeMillis */> delayLevelTable =
        new ConcurrentHashMap<Integer, Long>(32);

    // 偏移量
    private final ConcurrentMap<Integer /* level */, Long/* offset */> offsetTable =
        new ConcurrentHashMap<Integer, Long>(32);
    private final DefaultMessageStore defaultMessageStore;
    private final AtomicBoolean started = new AtomicBoolean(false);
    private Timer timer;
    private MessageStore writeMessageStore;
    // 最大延时级别
    private int maxDelayLevel;
}
```

#### 服务启动
延时级别、偏移量、定时器的初始化时机？在服务启动时，会对以上重要属性进行初始化。主要做这几件事：

+ 创建定时器对象，毕竟所有的操作都依赖它来完成，是真正的牛马
+ 加载`offsetTable`，提交持久化任务到定时器中，以固定速率（10s）执行
+ 遍历`delayLevelTable`，为每个延时级别创建消息发送任务，提交到定时器

```java
public void start() {
    if (started.compareAndSet(false, true)) {
        super.load();
        this.timer = new Timer("ScheduleMessageTimerThread", true);
        for (Map.Entry<Integer, Long> entry : this.delayLevelTable.entrySet()) {
            Integer level = entry.getKey();
            Long timeDelay = entry.getValue();
            // 根据延时级别获取消息队列消费进度，说明每个延时级别对应一个消息队列
            Long offset = this.offsetTable.get(level);
            if (null == offset) {
                offset = 0L;
            }

            // 启动时，延时1s执行n次调度任务
            if (timeDelay != null) {
                this.timer.schedule(new DeliverDelayedMessageTimerTask(level, offset), FIRST_DELAY_TIME);
            }
        }

        // 每10s持久化延时消息队列进度
        this.timer.scheduleAtFixedRate(new TimerTask() {

            @Override
            public void run() {
                try {
                    if (started.get()) {
                        ScheduleMessageService.this.persist();
                    }
                } catch (Throwable e) {
                    log.error("scheduleAtFixedRate flush exception", e);
                }
            }
        }, 10000, this.defaultMessageStore.getMessageStoreConfig().getFlushDelayOffsetInterval());
    }
}
```

#### 消息转发
提交到定时器的延时发送任务，会定时检查消息是否抵达发送时间

```java
public void executeOnTimeup() {
    // 根据延时消息主题和消息队列Id拿到消息队列
    ConsumeQueue cq =
        ScheduleMessageService.this.defaultMessageStore.findConsumeQueue(TopicValidator.RMQ_SYS_SCHEDULE_TOPIC,
            delayLevel2QueueId(delayLevel));

    long failScheduleOffset = offset;

    if (cq != null) {
        SelectMappedBufferResult bufferCQ = cq.getIndexBuffer(this.offset);
        if (bufferCQ != null) {
            try {
                long nextOffset = offset;
                int i = 0;
                ConsumeQueueExt.CqExtUnit cqExtUnit = new ConsumeQueueExt.CqExtUnit();
                for (; i < bufferCQ.getSize(); i += ConsumeQueue.CQ_STORE_UNIT_SIZE) {
                    long offsetPy = bufferCQ.getByteBuffer().getLong();
                    int sizePy = bufferCQ.getByteBuffer().getInt();
                    long tagsCode = bufferCQ.getByteBuffer().getLong();

                    if (cq.isExtAddr(tagsCode)) {
                        if (cq.getExt(tagsCode, cqExtUnit)) {
                            tagsCode = cqExtUnit.getTagsCode();
                        } else {
                            //can't find ext content.So re compute tags code.
                            log.error("[BUG] can't find consume queue extend file content!addr={}, offsetPy={}, sizePy={}",
                                tagsCode, offsetPy, sizePy);
                            long msgStoreTime = defaultMessageStore.getCommitLog().pickupStoreTimestamp(offsetPy, sizePy);
                            tagsCode = computeDeliverTimestamp(delayLevel, msgStoreTime);
                        }
                    }

                    long now = System.currentTimeMillis();
                    // 消息需要发送时间（消息真实的发送时间 + 延时时间）
                    long deliverTimestamp = this.correctDeliverTimestamp(now, tagsCode);

                    nextOffset = offset + (i / ConsumeQueue.CQ_STORE_UNIT_SIZE);

                    // 是否需要发送（消息真实的发送时间 + 延时时间） - now
                    long countdown = deliverTimestamp - now;

                    if (countdown <= 0) {
                        // 消息已经达到延时了，该发送出去了
                        MessageExt msgExt =
                            ScheduleMessageService.this.defaultMessageStore.lookMessageByOffset(
                                offsetPy, sizePy);

                        if (msgExt != null) {
                            try {
                                // 恢复真实主题和消息队列Id
                                MessageExtBrokerInner msgInner = this.messageTimeup(msgExt);
                                if (TopicValidator.RMQ_SYS_TRANS_HALF_TOPIC.equals(msgInner.getTopic())) {
                                    log.error("[BUG] the real topic of schedule msg is {}, discard the msg. msg={}",
                                        msgInner.getTopic(), msgInner);
                                    continue;
                                }

                                // 发送消息到broker
                                PutMessageResult putMessageResult =
                                    ScheduleMessageService.this.writeMessageStore
                                        .putMessage(msgInner);

                                if (putMessageResult != null
                                    && putMessageResult.getPutMessageStatus() == PutMessageStatus.PUT_OK) {
                                    if (ScheduleMessageService.this.defaultMessageStore.getMessageStoreConfig().isEnableScheduleMessageStats()) {
                                        ScheduleMessageService.this.defaultMessageStore.getBrokerStatsManager().incQueueGetNums(MixAll.SCHEDULE_CONSUMER_GROUP, TopicValidator.RMQ_SYS_SCHEDULE_TOPIC, delayLevel - 1, putMessageResult.getAppendMessageResult().getMsgNum());
                                        ScheduleMessageService.this.defaultMessageStore.getBrokerStatsManager().incQueueGetSize(MixAll.SCHEDULE_CONSUMER_GROUP, TopicValidator.RMQ_SYS_SCHEDULE_TOPIC, delayLevel - 1, putMessageResult.getAppendMessageResult().getWroteBytes());
                                        ScheduleMessageService.this.defaultMessageStore.getBrokerStatsManager().incGroupGetNums(MixAll.SCHEDULE_CONSUMER_GROUP, TopicValidator.RMQ_SYS_SCHEDULE_TOPIC, putMessageResult.getAppendMessageResult().getMsgNum());
                                        ScheduleMessageService.this.defaultMessageStore.getBrokerStatsManager().incGroupGetSize(MixAll.SCHEDULE_CONSUMER_GROUP, TopicValidator.RMQ_SYS_SCHEDULE_TOPIC, putMessageResult.getAppendMessageResult().getWroteBytes());
                                        ScheduleMessageService.this.defaultMessageStore.getBrokerStatsManager().incTopicPutNums(msgInner.getTopic(), putMessageResult.getAppendMessageResult().getMsgNum(), 1);
                                        ScheduleMessageService.this.defaultMessageStore.getBrokerStatsManager().incTopicPutSize(msgInner.getTopic(),
                                            putMessageResult.getAppendMessageResult().getWroteBytes());
                                        ScheduleMessageService.this.defaultMessageStore.getBrokerStatsManager().incBrokerPutNums(putMessageResult.getAppendMessageResult().getMsgNum());
                                    }
                                    continue;
                                } else {
                                    // XXX: warn and notify me
                                    log.error(
                                        "ScheduleMessageService, a message time up, but reput it failed, topic: {} msgId {}",
                                        msgExt.getTopic(), msgExt.getMsgId());
                                    ScheduleMessageService.this.timer.schedule(
                                        new DeliverDelayedMessageTimerTask(this.delayLevel,
                                            nextOffset), DELAY_FOR_A_PERIOD);
                                    ScheduleMessageService.this.updateOffset(this.delayLevel,
                                        nextOffset);
                                    return;
                                }
                            } catch (Exception e) {
                                /*
                                 * XXX: warn and notify me
                                 */
                                log.error(
                                    "ScheduleMessageService, messageTimeup execute error, drop it. msgExt={}, nextOffset={}, offsetPy={}, sizePy={}", msgExt, nextOffset, offsetPy, sizePy, e);
                            }
                        }
                    } else {
                        // 进行下次定时任务处理的放入
                        ScheduleMessageService.this.timer.schedule(
                            new DeliverDelayedMessageTimerTask(this.delayLevel, nextOffset),
                            countdown);
                        // 更新延时消息的消费进度
                        ScheduleMessageService.this.updateOffset(this.delayLevel, nextOffset);
                        return;
                    }
                } // end of for

                nextOffset = offset + (i / ConsumeQueue.CQ_STORE_UNIT_SIZE);
                ScheduleMessageService.this.timer.schedule(new DeliverDelayedMessageTimerTask(
                    this.delayLevel, nextOffset), DELAY_FOR_A_WHILE);
                // 更新延时消息的消费进度
                ScheduleMessageService.this.updateOffset(this.delayLevel, nextOffset);
                return;
            } finally {

                bufferCQ.release();
            }
        } // end of if (bufferCQ != null)
        else {

            long cqMinOffset = cq.getMinOffsetInQueue();
            long cqMaxOffset = cq.getMaxOffsetInQueue();
            if (offset < cqMinOffset) {
                failScheduleOffset = cqMinOffset;
                log.error("schedule CQ offset invalid. offset={}, cqMinOffset={}, cqMaxOffset={}, queueId={}",
                    offset, cqMinOffset, cqMaxOffset, cq.getQueueId());
            }

            if (offset > cqMaxOffset) {
                failScheduleOffset = cqMaxOffset;
                log.error("schedule CQ offset invalid. offset={}, cqMinOffset={}, cqMaxOffset={}, queueId={}",
                    offset, cqMinOffset, cqMaxOffset, cq.getQueueId());
            }
        }
    } // end of if (cq != null)

    ScheduleMessageService.this.timer.schedule(new DeliverDelayedMessageTimerTask(this.delayLevel,
        failScheduleOffset), DELAY_FOR_A_WHILE);
}
```

#### offset持久化
定时器每10s会去持久化 offset 一次。offset 是被序列化为 json 字符串，然后存储落盘。落盘流程：

+ 备份当前 offset 到后缀 tmp 临时文件
+ 备份最后一次落盘的 offset 信息到 bak 文件
+ 安全删除最后落盘的 offset 文件
+ 重命名 tmp，至此任务完成

持久化任务中，首先保证了 bak 和 tmp 的落盘。这样即使磁盘中 offset 删除，tmp 文件重命名失败，也不会导致最新的 offset 丢失。

```java
public synchronized void persist() {
    String jsonString = this.encode(true);
    if (jsonString != null) {
        String fileName = this.configFilePath();
        try {
            MixAll.string2File(jsonString, fileName);
        } catch (IOException e) {
            log.error("persist file " + fileName + " exception", e);
        }
    }
}

public static void string2File(final String str, final String fileName) throws IOException {
    String tmpFile = fileName + ".tmp";
    string2FileNotSafe(str, tmpFile);

    String bakFile = fileName + ".bak";
    String prevContent = file2String(fileName);
    if (prevContent != null) {
        string2FileNotSafe(prevContent, bakFile);
    }

    File file = new File(fileName);
    file.delete();

    file = new File(tmpFile);
    file.renameTo(new File(fileName));
}
```



### 1.初始化
#### 1.1 加载延时级别
从延时配置文件中加载内容，解析延时级别，根据空格分隔，转换为延时级别Map存储（Level -> TimeMillis）。加载消费队列消费offset，设置定时任务类属性offsetTable（Level -> offset）中，MQClient发送延时消息时，设置指定延时级别发送就可以



#### 1.2 计算延时队列偏移量
拿到延时主题（<font style="color:#067d17;">SCHEDULE_TOPIC_XXXX）</font>下的所有消费队列，遍历<font style="color:#871094;">delayLevelTable</font>，设置每个delay对应的offset。比对offsetTable的delayLevel和Topic下延时队列的offset，更正并更新offsetTable

更正条件：currentDelayOffset 不在 (cqMinOffset, cqMaxOffset) 中



### 2. 消息转发
#### 2.1 延时消息转发
遍历delayLevelTable，将延时级别和偏移量包装为任务扔入Timer线程



#### 2.2 offset持久化
以固定速率（10s）持久化offsetTable到文件中



#### 2.3 消息转发
拿到延时消费队列，根据offset拿到对应可读取的数据（Buffer）。计算当前时间是否超过消息发送时间（_<font style="color:#8c8c8c;">消息真实的发送时间 + 延时时间</font>_）

到达发送时间：恢复真实主题和消息队列Id，写入到真实主题对应文件中

未达发送时间：计算剩余发送时间，包装成任务扔入到Timer线程，更新offset，返回

更新offset



---

##### RocketMq延时消息
1. 加载配置文件中延时级别，加载到ScheduleMessageService中，放到delayLevelTable中
2. 每个延时级别对应着延时主题的一个延时队列（queueId = delayLevel - 1）
3. 定时消息是单独一个主题（Schedule_Topic_XXXX），主题下队列数量和延时级别一一对应。客户端发送定时消息时，会把真实主题及队列存储到消息体的属性中，替换主题延时主题和队列，最终转发到延时队列的消费队列中
4. 启动时，遍历延时级别表，获取对应偏移量并为每个延时级别创建定时器，1s后定时任务执行



##### 消息过滤
1. 拉取的时候进行消息过滤，如果设置了某个主题下自己感兴趣的tag，则在拉取时，设置拉取请求头，根据主题、消息tag去broker拉取指定消息
2. 针对拉取结果进行过滤，留下包含订阅Tag的消息，跳过不包含订阅Tag的消息

